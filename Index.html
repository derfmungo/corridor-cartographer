<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
  <meta name="theme-color" content="#0b0d12" />
  <link rel="manifest" href="manifest.json" />
  <link rel="apple-touch-icon" href="icon-192.png" />
  <title>Corridor Cartographer</title>
  <style>
    :root { color-scheme: dark; }
    html, body { margin:0; height:100%; background:#0b0d12; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #wrap { position:fixed; inset:0; display:flex; align-items:stretch; justify-content:center; }
    #game {
      width:100vw; height:100vh;
      touch-action: none;
      image-rendering: pixelated;
      background: #0b0d12;
      display:block;
    }

    /* HUD overlay */
    #hud {
      position:fixed; inset:0; pointer-events:none;
      padding: max(10px, env(safe-area-inset-top)) max(10px, env(safe-area-inset-right))
               max(10px, env(safe-area-inset-bottom)) max(10px, env(safe-area-inset-left));
    }
    .row { display:flex; gap:10px; align-items:center; justify-content:space-between; }
    .pill {
      pointer-events:none;
      padding:8px 10px; border-radius:14px;
      background: rgba(20,24,34,.75);
      border: 1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(6px);
      font-size: 13px;
      color: rgba(255,255,255,.9);
      display:flex; align-items:center; gap:10px;
      min-width: 120px;
    }
    .bar {
      width: 140px; height: 10px; border-radius: 999px;
      background: rgba(255,255,255,.12);
      overflow:hidden;
    }
    .fill { height:100%; width: 50%; background: rgba(255,255,255,.85); }
    .tiny { opacity:.85; font-size:12px; }
    .right { margin-left:auto; }

    /* Touch controls */
    #controls {
      position:fixed; inset:0;
      padding: max(10px, env(safe-area-inset-top)) max(10px, env(safe-area-inset-right))
               max(10px, env(safe-area-inset-bottom)) max(10px, env(safe-area-inset-left));
      pointer-events:none;
    }
    .joystick {
      position:absolute; left:14px; bottom:14px;
      width:140px; height:140px; border-radius:999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.08);
      pointer-events:auto;
      display:flex; align-items:center; justify-content:center;
    }
    .stick {
      width:54px; height:54px; border-radius:999px;
      background: rgba(255,255,255,.12);
      border: 1px solid rgba(255,255,255,.16);
      transform: translate(0px, 0px);
    }
    .btns {
      position:absolute; right:14px; bottom:14px;
      display:flex; flex-direction:column; gap:12px;
      pointer-events:auto;
    }
    .btn {
      width:84px; height:84px; border-radius:22px;
      background: rgba(255,255,255,.08);
      border: 1px solid rgba(255,255,255,.10);
      display:flex; align-items:center; justify-content:center;
      font-weight:700;
      user-select:none;
      -webkit-user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:active { transform: scale(0.98); background: rgba(255,255,255,.12); }
    .btn small { display:block; font-weight:600; opacity:.85; margin-top:2px; font-size:11px; }

    /* Menus */
    #menu {
      position:fixed; inset:0;
      display:flex; align-items:center; justify-content:center;
      padding: 18px;
      background: radial-gradient(1200px 800px at 50% 30%, rgba(120,160,255,.10), transparent 70%),
                  radial-gradient(900px 600px at 60% 60%, rgba(255,140,200,.08), transparent 70%),
                  #0b0d12;
      color: rgba(255,255,255,.92);
    }
    .panel {
      width: min(560px, 100%);
      border-radius: 22px;
      background: rgba(20,24,34,.75);
      border: 1px solid rgba(255,255,255,.10);
      box-shadow: 0 18px 80px rgba(0,0,0,.45);
      backdrop-filter: blur(10px);
      padding: 18px;
    }
    h1 { margin: 6px 0 4px; font-size: 24px; letter-spacing: .4px; }
    .subtitle { margin:0 0 14px; opacity:.85; font-size:13px; }
    .grid { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .bigbtn {
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.08);
      color: rgba(255,255,255,.92);
      border-radius: 16px;
      padding: 12px 12px;
      font-weight: 750;
      cursor:pointer;
      text-align:left;
    }
    .bigbtn:active { transform: scale(0.99); background: rgba(255,255,255,.12); }
    .bigbtn .hint { display:block; font-size: 12px; opacity:.75; font-weight:600; margin-top:4px; }
    .line { height:1px; background: rgba(255,255,255,.10); margin: 12px 0; }
    .list { display:flex; flex-direction:column; gap:8px; }
    .row2 { display:flex; justify-content:space-between; gap:10px; align-items:center; }
    .smallbtn {
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.08);
      color: rgba(255,255,255,.92);
      border-radius: 14px;
      padding: 10px 10px;
      font-weight: 700;
      cursor:pointer;
    }
    .smallbtn:active { transform: scale(0.99); background: rgba(255,255,255,.12); }
    .note { font-size: 12px; opacity:.82; line-height: 1.35; }
    .kbd { padding: 1px 6px; border-radius: 8px; border:1px solid rgba(255,255,255,.14); background: rgba(255,255,255,.06); font-weight:700; font-size:12px; }
    .muted { opacity:.75; }

    @media (max-width: 460px){
      .grid { grid-template-columns: 1fr; }
      .pill { min-width: 0; }
      .bar { width: 120px; }
    }
  </style>
</head>
<body>
  <div id="wrap"><canvas id="game"></canvas></div>

  <div id="hud" aria-hidden="true" style="display:none;">
    <div class="row">
      <div class="pill">
        <span style="font-weight:800;">HP</span>
        <div class="bar"><div id="hpFill" class="fill"></div></div>
        <span id="hpText" class="tiny">—</span>
      </div>

      <div class="pill right">
        <span style="font-weight:800;">RUN</span>
        <span id="runText" class="tiny">Depth 0 • 0 Aether</span>
      </div>
    </div>

    <div style="height:10px;"></div>

    <div class="row">
      <div class="pill">
        <span style="font-weight:800;">RELICS</span>
        <span id="relicText" class="tiny">0/3</span>
      </div>
      <div class="pill right">
        <span style="font-weight:800;">HELP</span>
        <span class="tiny"><span class="kbd">WASD</span> <span class="kbd">Space</span> <span class="kbd">Shift</span> <span class="kbd">Esc</span></span>
      </div>
    </div>
  </div>

  <div id="controls" aria-hidden="true" style="display:none;">
    <div class="joystick" id="joy">
      <div class="stick" id="stick"></div>
    </div>
    <div class="btns">
      <div class="btn" id="btnAttack">ATTACK<small>tap</small></div>
      <div class="btn" id="btnDash">DASH<small>tap</small></div>
      <div class="btn" id="btnPause">PAUSE<small>menu</small></div>
    </div>
  </div>

  <div id="menu">
    <div class="panel" id="panelMain">
      <h1>Corridor Cartographer</h1>
      <p class="subtitle">A pocket roguelite in an infinite hallscape. Grab relics, dodge wardens, find the exit.</p>

      <div class="grid">
        <button class="bigbtn" id="playBtn">
          Play
          <span class="hint">New run • touch + keyboard supported</span>
        </button>
        <button class="bigbtn" id="upgradesBtn">
          Upgrades
          <span class="hint">Spend Aether (meta currency)</span>
        </button>
        <button class="bigbtn" id="howBtn">
          How to play
          <span class="hint">Controls • goals • tips</span>
        </button>
        <button class="bigbtn" id="settingsBtn">
          Settings
          <span class="hint">Sound • vibration • reset</span>
        </button>
      </div>

      <div class="line"></div>
      <div class="row2">
        <div class="note">
          <div><b>Meta Aether:</b> <span id="metaAether">0</span></div>
          <div class="muted">Installable as an offline PWA (see readme-ish notes at bottom of this file).</div>
        </div>
        <button class="smallbtn" id="resumeBtn" style="display:none;">Resume</button>
      </div>
    </div>

    <div class="panel" id="panelUpgrades" style="display:none;">
      <h1>Upgrades</h1>
      <p class="subtitle">Permanent perks. The hallscape hates this.</p>

      <div class="list" id="upgradeList"></div>

      <div class="line"></div>
      <div class="row2">
        <div class="note">Meta Aether: <b id="metaAether2">0</b></div>
        <button class="smallbtn" id="backFromUpgrades">Back</button>
      </div>
    </div>

    <div class="panel" id="panelHow" style="display:none;">
      <h1>How to play</h1>
      <p class="subtitle">Short version: don’t get hugged by the Warden.</p>

      <div class="note" style="line-height:1.5;">
        <b>Goal</b>: Collect <b>3 Relics</b>, then a shimmering <b>Exit</b> appears. Step into it to finish the run and bank bonuses.<br><br>
        <b>Depth</b> increases as you explore farther from the origin. Every few depth milestones, the hallscape spawns a <b>Warden</b> (big, fast, rude).<br><br>
        <b>Pickups</b>: Aether (currency), Hearts (heal), Relics (progress).<br><br>
        <b>Controls</b>:
        <ul>
          <li><b>Phone</b>: Left joystick moves. Buttons: Attack / Dash / Pause.</li>
          <li><b>Keyboard</b>: <span class="kbd">WASD</span> move, <span class="kbd">Space</span> attack, <span class="kbd">Shift</span> dash, <span class="kbd">Esc</span> menu.</li>
        </ul>
        <b>Tip</b>: Dash has i-frames (brief invulnerability). Use it like a hall-pass from physics.
      </div>

      <div class="line"></div>
      <div class="row2">
        <div class="note muted">This is a complete single-player offline game. No ads. No servers. No weirdness.</div>
        <button class="smallbtn" id="backFromHow">Back</button>
      </div>
    </div>

    <div class="panel" id="panelSettings" style="display:none;">
      <h1>Settings</h1>
      <p class="subtitle">Tweak the vibe. Or delete reality (save reset).</p>

      <div class="list">
        <div class="row2">
          <div class="note"><b>Sound</b></div>
          <button class="smallbtn" id="toggleSound">On</button>
        </div>
        <div class="row2">
          <div class="note"><b>Vibration</b> (if supported)</div>
          <button class="smallbtn" id="toggleVibe">On</button>
        </div>
        <div class="row2">
          <div class="note"><b>Reset all saves</b><br><span class="muted">Aether + upgrades wiped.</span></div>
          <button class="smallbtn" id="resetSaves">Reset</button>
        </div>
      </div>

      <div class="line"></div>
      <div class="row2">
        <div class="note muted">Install tips: serve over HTTPS (or localhost). iOS: Share → Add to Home Screen.</div>
        <button class="smallbtn" id="backFromSettings">Back</button>
      </div>
    </div>

    <div class="panel" id="panelPause" style="display:none;">
      <h1>Paused</h1>
      <p class="subtitle">The hallscape politely stops trying to kill you.</p>
      <div class="grid">
        <button class="bigbtn" id="continueBtn">Continue<span class="hint">Back to the corridor</span></button>
        <button class="bigbtn" id="quitBtn">Quit to menu<span class="hint">End run (keeps meta Aether)</span></button>
      </div>
      <div class="line"></div>
      <div class="note muted">Pro tip: quitting mid-run is allowed. The hallscape will still judge you, but quietly.</div>
    </div>
  </div>

<script>
(() => {
  // ---------------------------
  // Utilities
  // ---------------------------
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const dist2 = (ax, ay, bx, by) => {
    const dx = ax - bx, dy = ay - by;
    return dx*dx + dy*dy;
  };

  // Deterministic-ish chunk PRNG
  const xfnv1a = (str) => {
    let h = 2166136261 >>> 0;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return h >>> 0;
  };
  const mulberry32 = (seed) => {
    let t = seed >>> 0;
    return () => {
      t += 0x6D2B79F5;
      let r = Math.imul(t ^ (t >>> 15), 1 | t);
      r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
      return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
    };
  };

  // Tiny audio bleeps (WebAudio)
  let audioCtx = null;
  const SFX = {
    enabled: true,
    beep(freq=440, dur=0.06, gain=0.05, type="square"){
      if (!SFX.enabled) return;
      try{
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const o = audioCtx.createOscillator();
        const g = audioCtx.createGain();
        o.type = type;
        o.frequency.value = freq;
        g.gain.value = gain;
        o.connect(g); g.connect(audioCtx.destination);
        o.start();
        o.stop(audioCtx.currentTime + dur);
      }catch(_){}
    },
    hit(){ SFX.beep(180, 0.07, 0.06, "square"); },
    pickup(){ SFX.beep(720, 0.05, 0.04, "triangle"); },
    relic(){ SFX.beep(900, 0.08, 0.05, "sine"); SFX.beep(1200, 0.05, 0.03, "sine"); },
    dash(){ SFX.beep(520, 0.05, 0.04, "sawtooth"); },
    hurt(){ SFX.beep(120, 0.10, 0.07, "square"); },
    menu(){ SFX.beep(600, 0.04, 0.03, "triangle"); }
  };

  const VIBE = {
    enabled: true,
    tap(ms=20){ if (VIBE.enabled && navigator.vibrate) navigator.vibrate(ms); }
  };

  // ---------------------------
  // Save + Meta
  // ---------------------------
  const SAVE_KEY = "cc_save_v1";
  const defaultSave = () => ({
    metaAether: 0,
    upgrades: { maxHp: 0, atk: 0, dash: 0 },
    settings: { sound: true, vibe: true }
  });

  const loadSave = () => {
    try{
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return defaultSave();
      const s = JSON.parse(raw);
      const d = defaultSave();
      // merge
      return {
        metaAether: Number(s.metaAether ?? d.metaAether),
        upgrades: { ...d.upgrades, ...(s.upgrades||{}) },
        settings: { ...d.settings, ...(s.settings||{}) },
      };
    }catch(_){
      return defaultSave();
    }
  };

  const saveNow = () => {
    localStorage.setItem(SAVE_KEY, JSON.stringify(save));
    syncSettings();
    updateMenuNumbers();
  };

  let save = loadSave();

  function syncSettings(){
    SFX.enabled = !!save.settings.sound;
    VIBE.enabled = !!save.settings.vibe;
    document.getElementById("toggleSound").textContent = SFX.enabled ? "On" : "Off";
    document.getElementById("toggleVibe").textContent = VIBE.enabled ? "On" : "Off";
  }

  // Upgrades catalog
  const UPGRADES = [
    {
      key: "maxHp",
      name: "Sturdier Skeleton",
      desc: "+10 max HP per level",
      baseCost: 25,
      costMult: 1.75,
      max: 8,
      apply: (lvl) => 10 * lvl
    },
    {
      key: "atk",
      name: "Sharper Intent",
      desc: "+12% attack damage per level",
      baseCost: 30,
      costMult: 1.85,
      max: 8,
      apply: (lvl) => 0.12 * lvl
    },
    {
      key: "dash",
      name: "Greased Reality",
      desc: "-8% dash cooldown per level",
      baseCost: 20,
      costMult: 1.65,
      max: 8,
      apply: (lvl) => 0.08 * lvl
    }
  ];

  const upgradeCost = (u, lvl) => Math.floor(u.baseCost * Math.pow(u.costMult, lvl));
  const fmt = (n) => (Math.floor(n)).toString();

  // ---------------------------
  // Canvas + Scaling
  // ---------------------------
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha: false });

  // Logical resolution (scaled to screen)
  let W = 360, H = 640;
  function resize(){
    const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const ww = Math.max(320, window.innerWidth);
    const hh = Math.max(480, window.innerHeight);
    canvas.style.width = ww + "px";
    canvas.style.height = hh + "px";
    canvas.width = Math.floor(ww * dpr);
    canvas.height = Math.floor(hh * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    // Use CSS px coordinate system in draw.
    W = ww; H = hh;
  }
  window.addEventListener("resize", resize);
  resize();

  // ---------------------------
  // Game Constants
  // ---------------------------
  const TILE = 24;
  const CHUNK = 32; // tiles
  const SOLID = 1, FLOOR = 0;

  const COLORS = {
    bg: "#0b0d12",
    wall: "#1b2131",
    wall2: "#151a28",
    floor: "#0f1320",
    floor2: "#11172a",
    glow: "rgba(170,210,255,0.20)",
    player: "#dce6ff",
    enemy: "#ff9cc8",
    warden: "#ffcc66",
    aether: "#a0d9ff",
    heart: "#ff6b7b",
    relic: "#b9ff9c",
    exit: "#caa2ff",
    text: "rgba(255,255,255,0.92)",
    muted: "rgba(255,255,255,0.68)"
  };

  // ---------------------------
  // World generation (chunks)
  // ---------------------------
  const chunkCache = new Map(); // key -> {tiles: Uint8Array, decor: Uint8Array, spawns: [...], exits: [...]}

  function chunkKey(cx, cy){ return cx + "," + cy; }

  function getChunk(cx, cy){
    const key = chunkKey(cx, cy);
    if (chunkCache.has(key)) return chunkCache.get(key);

    const seed = xfnv1a("cc|v1|" + key);
    const rnd = mulberry32(seed);

    const tiles = new Uint8Array(CHUNK * CHUNK);
    const decor = new Uint8Array(CHUNK * CHUNK); // 0 none, 1 speckle, 2 crack
    tiles.fill(SOLID);

    // Carve rooms/corridors
    const rooms = [];
    const roomCount = 4 + Math.floor(rnd() * 4); // 4-7

    for (let i = 0; i < roomCount; i++){
      const rw = 6 + Math.floor(rnd() * 10);
      const rh = 6 + Math.floor(rnd() * 10);
      const rx = 2 + Math.floor(rnd() * (CHUNK - rw - 4));
      const ry = 2 + Math.floor(rnd() * (CHUNK - rh - 4));
      rooms.push({x:rx,y:ry,w:rw,h:rh, cx: rx + (rw>>1), cy: ry + (rh>>1)});
      for (let y = ry; y < ry + rh; y++){
        for (let x = rx; x < rx + rw; x++){
          tiles[y*CHUNK + x] = FLOOR;
          if (rnd() < 0.05) decor[y*CHUNK + x] = 1;
          if (rnd() < 0.015) decor[y*CHUNK + x] = 2;
        }
      }
    }

    // Connect rooms
    rooms.sort((a,b)=>a.cx-b.cx);
    for (let i = 1; i < rooms.length; i++){
      const a = rooms[i-1], b = rooms[i];
      let x = a.cx, y = a.cy;
      // horizontal
      while (x !== b.cx){
        tiles[y*CHUNK + x] = FLOOR;
        x += (b.cx > x) ? 1 : -1;
      }
      // vertical
      while (y !== b.cy){
        tiles[y*CHUNK + x] = FLOOR;
        y += (b.cy > y) ? 1 : -1;
      }
    }

    // Ensure chunk edges have some openings (so the world actually connects)
    const punch = (edge) => {
      // edge: 0 top,1 right,2 bottom,3 left
      const openings = 1 + Math.floor(rnd()*2); // 1-2
      for (let i=0;i<openings;i++){
        const t = 6 + Math.floor(rnd()*(CHUNK-12));
        for (let k=0;k<3;k++){
          let x=t+k, y=t+k;
          if (edge===0){ x=t+k; y=0; }
          if (edge===2){ x=t+k; y=CHUNK-1; }
          if (edge===3){ x=0; y=t+k; }
          if (edge===1){ x=CHUNK-1; y=t+k; }
          tiles[y*CHUNK + x] = FLOOR;
        }
      }
    };
    punch(0); punch(1); punch(2); punch(3);

    // Spawns
    const spawns = [];
    const pickupSpawns = [];

    const depth = Math.abs(cx) + Math.abs(cy);

    // place some enemies + pickups on floor tiles
    const tries = 45;
    for (let i=0;i<tries;i++){
      const x = 1 + Math.floor(rnd()*(CHUNK-2));
      const y = 1 + Math.floor(rnd()*(CHUNK-2));
      if (tiles[y*CHUNK + x] !== FLOOR) continue;

      const roll = rnd();
      if (roll < 0.10 + Math.min(0.06, depth*0.002)){
        // enemy
        spawns.push({ kind:"stalker", tx:x, ty:y });
      }else if (roll < 0.15){
        // aether
        pickupSpawns.push({ kind:"aether", tx:x, ty:y, amt: 4 + Math.floor(rnd()*8) });
      }else if (roll < 0.165){
        // heart
        pickupSpawns.push({ kind:"heart", tx:x, ty:y, amt: 10 });
      }
    }

    // Rare relic chance (but player needs 3 total, so not too rare)
    if (rnd() < 0.16){
      // find a floor tile near a room center
      const r = rooms[Math.floor(rnd()*rooms.length)];
      pickupSpawns.push({ kind:"relic", tx:r.cx, ty:r.cy, amt:1 });
    }

    const chunk = { tiles, decor, spawns, pickupSpawns, seed };
    chunkCache.set(key, chunk);
    return chunk;
  }

  function tileAt(worldX, worldY){
    // worldX/Y in tiles (float ok)
    const tx = Math.floor(worldX);
    const ty = Math.floor(worldY);
    const cx = Math.floor(tx / CHUNK);
    const cy = Math.floor(ty / CHUNK);
    const lx = ((tx % CHUNK) + CHUNK) % CHUNK;
    const ly = ((ty % CHUNK) + CHUNK) % CHUNK;
    const chunk = getChunk(cx, cy);
    return chunk.tiles[ly*CHUNK + lx];
  }

  function decorAt(tx, ty){
    const cx = Math.floor(tx / CHUNK);
    const cy = Math.floor(ty / CHUNK);
    const lx = ((tx % CHUNK) + CHUNK) % CHUNK;
    const ly = ((ty % CHUNK) + CHUNK) % CHUNK;
    const chunk = getChunk(cx, cy);
    return chunk.decor[ly*CHUNK + lx] || 0;
  }

  // ---------------------------
  // Entities
  // ---------------------------
  const entities = [];
  const pickups = [];
  const picked = new Set(); // deterministic pickup ids collected
  const spawnedChunks = new Set();

  function worldToChunkTile(tx, ty){
    const cx = Math.floor(tx / CHUNK);
    const cy = Math.floor(ty / CHUNK);
    const lx = ((tx % CHUNK) + CHUNK) % CHUNK;
    const ly = ((ty % CHUNK) + CHUNK) % CHUNK;
    return { cx, cy, lx, ly };
  }

  function pickupId(cx, cy, i){ return `p:${cx},${cy}:${i}`; }
  function enemyId(cx, cy, i){ return `e:${cx},${cy}:${i}`; }

  function ensureChunkSpawnsAround(px, py){
    const tx = Math.floor(px);
    const ty = Math.floor(py);
    const pcx = Math.floor(tx / CHUNK);
    const pcy = Math.floor(ty / CHUNK);

    for (let cy = pcy-1; cy <= pcy+1; cy++){
      for (let cx = pcx-1; cx <= pcx+1; cx++){
        const key = chunkKey(cx, cy);
        if (spawnedChunks.has(key)) continue;
        spawnedChunks.add(key);

        const c = getChunk(cx, cy);

        // enemies
        c.spawns.forEach((s, i) => {
          const id = enemyId(cx, cy, i);
          // enemies are per-run; always spawn (but can despawn later)
          entities.push(makeEnemy(
            (cx*CHUNK + s.tx) + 0.5,
            (cy*CHUNK + s.ty) + 0.5,
            s.kind,
            id
          ));
        });

        // pickups
        c.pickupSpawns.forEach((p, i) => {
          const id = pickupId(cx, cy, i);
          if (picked.has(id)) return;
          pickups.push(makePickup(
            (cx*CHUNK + p.tx) + 0.5,
            (cy*CHUNK + p.ty) + 0.5,
            p.kind,
            p.amt,
            id
          ));
        });
      }
    }
  }

  function cullFarEntities(px, py){
    const maxDistTiles = 80; // soft cap
    for (let i = entities.length - 1; i >= 0; i--){
      const e = entities[i];
      if (Math.abs(e.x - px) > maxDistTiles || Math.abs(e.y - py) > maxDistTiles){
        entities.splice(i, 1);
      }
    }
    for (let i = pickups.length - 1; i >= 0; i--){
      const p = pickups[i];
      if (Math.abs(p.x - px) > maxDistTiles || Math.abs(p.y - py) > maxDistTiles){
        pickups.splice(i, 1);
      }
    }
  }

  function makePickup(x, y, kind, amt, id){
    return {
      x, y, kind, amt, id,
      r: 0.30,
      bob: Math.random()*10,
      draw(ctx, cam){
        const px = (this.x - cam.x) * TILE + cam.w/2;
        const py = (this.y - cam.y) * TILE + cam.h/2;
        const t = (performance.now()*0.001 + this.bob);
        const off = Math.sin(t*2.2) * 3;

        ctx.save();
        ctx.translate(px, py + off);

        if (kind === "aether"){
          ctx.fillStyle = COLORS.aether;
          ctx.beginPath();
          ctx.moveTo(0, -8); ctx.lineTo(7, 0); ctx.lineTo(0, 8); ctx.lineTo(-7, 0);
          ctx.closePath();
          ctx.fill();
        }else if (kind === "heart"){
          ctx.fillStyle = COLORS.heart;
          ctx.beginPath();
          ctx.moveTo(0, 6);
          ctx.bezierCurveTo(-10, -2, -6, -10, 0, -4);
          ctx.bezierCurveTo(6, -10, 10, -2, 0, 6);
          ctx.fill();
        }else if (kind === "relic"){
          ctx.fillStyle = COLORS.relic;
          ctx.beginPath();
          ctx.arc(0,0,7,0,Math.PI*2);
          ctx.fill();
          ctx.strokeStyle = "rgba(0,0,0,0.35)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(0,0,7,0,Math.PI*2);
          ctx.stroke();
        }else if (kind === "exit"){
          ctx.fillStyle = COLORS.exit;
          ctx.beginPath();
          ctx.arc(0,0,12,0,Math.PI*2);
          ctx.fill();
          ctx.globalAlpha = 0.65;
          ctx.fillStyle = "rgba(255,255,255,0.45)";
          ctx.beginPath();
          ctx.arc(0,0,7,0,Math.PI*2);
          ctx.fill();
        }

        ctx.restore();
      }
    };
  }

  function makeEnemy(x, y, kind, id){
    const isWarden = (kind === "warden");
    return {
      x, y, vx:0, vy:0, kind, id,
      r: isWarden ? 0.55 : 0.45,
      hp: isWarden ? 140 : 45,
      maxHp: isWarden ? 140 : 45,
      dmg: isWarden ? 22 : 12,
      speed: isWarden ? 2.6 : 1.9,
      hitCD: 0,
      flash: 0,
      alive: true,
      draw(ctx, cam){
        const px = (this.x - cam.x) * TILE + cam.w/2;
        const py = (this.y - cam.y) * TILE + cam.h/2;

        ctx.save();
        ctx.translate(px, py);

        // body
        ctx.fillStyle = (this.flash > 0) ? "white" : (isWarden ? COLORS.warden : COLORS.enemy);
        ctx.beginPath();
        ctx.arc(0,0, this.r*TILE, 0, Math.PI*2);
        ctx.fill();

        // eyes (because hallscape)
        ctx.fillStyle = "rgba(0,0,0,0.35)";
        ctx.beginPath(); ctx.arc(-6, -4, 3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(6, -4, 3, 0, Math.PI*2); ctx.fill();

        // HP tick on wardens
        if (isWarden){
          const w = 44, h = 6;
          ctx.translate(0, -this.r*TILE - 14);
          ctx.fillStyle = "rgba(255,255,255,0.14)";
          ctx.fillRect(-w/2, -h/2, w, h);
          ctx.fillStyle = "rgba(255,255,255,0.85)";
          ctx.fillRect(-w/2, -h/2, w*(this.hp/this.maxHp), h);
        }

        ctx.restore();
      }
    };
  }

  function makeSlash(x, y, dirx, diry, dmg){
    const len = 1.05;
    const sx = x + dirx*0.65;
    const sy = y + diry*0.65;
    const ex = x + dirx*len;
    const ey = y + diry*len;
    return { sx, sy, ex, ey, t: 0.12, dmg };
  }

  // ---------------------------
  // Player + Run State
  // ---------------------------
  const player = {
    x: 0.5, y: 0.5,
    vx: 0, vy: 0,
    r: 0.38,
    hp: 100,
    maxHp: 100,
    invuln: 0,
    atkCD: 0,
    dashCD: 0,
    dashTime: 0,
    dirx: 1, diry: 0,
    aether: 0,
    relics: 0,
    relicGate: false,
    exitSpawned: false
  };

  const run = {
    active: false,
    depth: 0,
    bestDepth: 0,
    wardensSpawnedAt: new Set(),
    slashes: [],
    particles: [],
    discovered: new Set(),
    msg: { text:"", t:0 }
  };

  function applyUpgrades(){
    const u = save.upgrades;
    const maxHpBonus = UPGRADES.find(x=>x.key==="maxHp").apply(u.maxHp);
    player.maxHp = 100 + maxHpBonus;
    player.hp = player.maxHp;
  }

  function getAtkMult(){
    const u = save.upgrades;
    const bonus = UPGRADES.find(x=>x.key==="atk").apply(u.atk);
    return 1 + bonus;
  }

  function getDashCooldownBase(){
    const base = 1.4;
    const u = save.upgrades;
    const red = UPGRADES.find(x=>x.key==="dash").apply(u.dash);
    return base * (1 - clamp(red, 0, 0.55));
  }

  function resetRun(){
    entities.length = 0;
    pickups.length = 0;
    picked.clear();
    spawnedChunks.clear();
    chunkCache.clear();
    run.slashes.length = 0;
    run.particles.length = 0;
    run.discovered.clear();
    run.wardensSpawnedAt.clear();
    run.msg = { text:"", t:0 };

    player.x = 0.5; player.y = 0.5;
    player.vx = 0; player.vy = 0;
    player.invuln = 0;
    player.atkCD = 0;
    player.dashCD = 0;
    player.dashTime = 0;
    player.dirx = 1; player.diry = 0;
    player.aether = 0;
    player.relics = 0;
    player.relicGate = false;
    player.exitSpawned = false;

    applyUpgrades();

    run.active = true;
    run.depth = 0;
    run.bestDepth = 0;

    // Ensure starting tile is floor; nudge if needed.
    if (tileAt(player.x, player.y) === SOLID){
      for (let i=0;i<200;i++){
        const x = (Math.random()*6 - 3) + 0.5;
        const y = (Math.random()*6 - 3) + 0.5;
        if (tileAt(x,y) === FLOOR){ player.x=x; player.y=y; break; }
      }
    }

    pushMsg("The hallscape stirs.");
  }

  function pushMsg(text, seconds=2.0){
    run.msg.text = text;
    run.msg.t = seconds;
  }

  // Spawn a Warden at certain depth milestones
  function maybeSpawnWarden(){
    const d = run.depth;
    if (d < 6) return;
    const milestone = Math.floor(d / 6); // every 6 depth "rings"
    if (run.wardensSpawnedAt.has(milestone)) return;
    run.wardensSpawnedAt.add(milestone);

    // spawn near player but not on top
    let sx = player.x, sy = player.y;
    for (let i=0;i<120;i++){
      const ang = Math.random()*Math.PI*2;
      const rr = 10 + Math.random()*14;
      const x = player.x + Math.cos(ang)*rr;
      const y = player.y + Math.sin(ang)*rr;
      if (tileAt(x,y) === FLOOR && dist2(x,y, player.x, player.y) > 120){
        sx=x; sy=y; break;
      }
    }
    entities.push(makeEnemy(sx, sy, "warden", "warden:"+milestone));
    pushMsg("A Warden awakens.");
    SFX.hit(); VIBE.tap(45);
  }

  function spawnExitNearPlayer(){
    if (player.exitSpawned) return;
    player.exitSpawned = true;
    // pick a nearby floor tile
    for (let i=0;i<220;i++){
      const ang = Math.random()*Math.PI*2;
      const rr = 6 + Math.random()*10;
      const x = player.x + Math.cos(ang)*rr;
      const y = player.y + Math.sin(ang)*rr;
      if (tileAt(x,y) === FLOOR){
        pickups.push(makePickup(x, y, "exit", 1, "EXIT"));
        pushMsg("An Exit shimmers into being.");
        SFX.relic(); VIBE.tap(60);
        return;
      }
    }
    // fallback right on player (rare)
    pickups.push(makePickup(player.x+2, player.y, "exit", 1, "EXIT"));
  }

  // ---------------------------
  // Input (keyboard + touch)
  // ---------------------------
  const input = {
    mx:0, my:0,
    moveX:0, moveY:0,
    attack:false,
    dash:false,
    pause:false
  };

  const keys = new Set();
  window.addEventListener("keydown", (e)=>{
    keys.add(e.code);
    if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
    if (e.code === "Escape") { input.pause = true; }
  }, {passive:false});
  window.addEventListener("keyup", (e)=> keys.delete(e.code));

  function pollKeyboard(){
    let x=0,y=0;
    if (keys.has("KeyW") || keys.has("ArrowUp")) y -= 1;
    if (keys.has("KeyS") || keys.has("ArrowDown")) y += 1;
    if (keys.has("KeyA") || keys.has("ArrowLeft")) x -= 1;
    if (keys.has("KeyD") || keys.has("ArrowRight")) x += 1;
    const m = Math.hypot(x,y) || 1;
    x/=m; y/=m;

    // touch overrides keyboard if present
    if (!touchJoy.active){
      input.moveX = x;
      input.moveY = y;
    }

    if (keys.has("Space")) input.attack = true;
    if (keys.has("ShiftLeft") || keys.has("ShiftRight")) input.dash = true;
  }

  // Touch joystick
  const joyEl = document.getElementById("joy");
  const stickEl = document.getElementById("stick");

  const touchJoy = { active:false, id:null, cx:0, cy:0, dx:0, dy:0 };

  function setStick(dx, dy){
    const max = 42;
    const mag = Math.hypot(dx,dy);
    const s = mag > max ? (max / mag) : 1;
    const x = dx*s, y = dy*s;
    stickEl.style.transform = `translate(${x}px, ${y}px)`;
  }

  function touchPos(t){
    const r = canvas.getBoundingClientRect();
    return { x: (t.clientX - r.left), y: (t.clientY - r.top) };
  }

  joyEl.addEventListener("pointerdown", (e)=>{
    joyEl.setPointerCapture(e.pointerId);
    touchJoy.active = true;
    touchJoy.id = e.pointerId;
    touchJoy.cx = e.clientX;
    touchJoy.cy = e.clientY;
    touchJoy.dx = 0;
    touchJoy.dy = 0;
    setStick(0,0);
    VIBE.tap(10);
  });

  joyEl.addEventListener("pointermove", (e)=>{
    if (!touchJoy.active || e.pointerId !== touchJoy.id) return;
    const dx = e.clientX - touchJoy.cx;
    const dy = e.clientY - touchJoy.cy;
    touchJoy.dx = dx;
    touchJoy.dy = dy;
    setStick(dx, dy);

    const max = 48;
    const mag = Math.hypot(dx,dy);
    let nx = dx, ny = dy;
    if (mag > max){ nx = dx * (max/mag); ny = dy * (max/mag); }
    input.moveX = clamp(nx / max, -1, 1);
    input.moveY = clamp(ny / max, -1, 1);
  });

  function joyUp(){
    touchJoy.active = false;
    touchJoy.id = null;
    input.moveX = 0;
    input.moveY = 0;
    setStick(0,0);
  }
  joyEl.addEventListener("pointerup", (e)=>{ if (e.pointerId===touchJoy.id) joyUp(); });
  joyEl.addEventListener("pointercancel", (e)=>{ if (e.pointerId===touchJoy.id) joyUp(); });

  // Buttons
  const btnAttack = document.getElementById("btnAttack");
  const btnDash = document.getElementById("btnDash");
  const btnPause = document.getElementById("btnPause");

  const press = (el, fn) => {
    el.addEventListener("pointerdown", (e)=>{
      el.setPointerCapture(e.pointerId);
      fn();
      VIBE.tap(12);
    });
  };

  press(btnAttack, ()=>{ input.attack = true; });
  press(btnDash, ()=>{ input.dash = true; });
  press(btnPause, ()=>{ input.pause = true; });

  // Prevent mobile scroll
  window.addEventListener("touchmove", (e)=> e.preventDefault(), {passive:false});

  // ---------------------------
  // Physics + collision
  // ---------------------------
  function isSolidAt(x,y){
    return tileAt(x,y) === SOLID;
  }

  function moveWithCollide(obj, dx, dy){
    // obj has x,y,r in tile units
    let nx = obj.x + dx;
    let ny = obj.y + dy;

    // X
    if (dx !== 0){
      const dir = Math.sign(dx);
      const edgeX = nx + dir*obj.r;
      const y0 = ny - obj.r;
      const y1 = ny + obj.r;
      // sample 3 points
      const samples = 3;
      let hit = false;
      for (let i=0;i<samples;i++){
        const t = i/(samples-1);
        const sy = lerp(y0,y1,t);
        if (isSolidAt(edgeX, sy)){ hit = true; break; }
      }
      if (hit){
        // push to boundary
        const tx = Math.floor(edgeX);
        if (dir > 0) nx = tx - obj.r - 0.001;
        else nx = (tx+1) + obj.r + 0.001;
        obj.vx = 0;
      }
    }

    // Y
    if (dy !== 0){
      const dir = Math.sign(dy);
      const edgeY = ny + dir*obj.r;
      const x0 = nx - obj.r;
      const x1 = nx + obj.r;
      const samples = 3;
      let hit = false;
      for (let i=0;i<samples;i++){
        const t = i/(samples-1);
        const sx = lerp(x0,x1,t);
        if (isSolidAt(sx, edgeY)){ hit = true; break; }
      }
      if (hit){
        const ty = Math.floor(edgeY);
        if (dir > 0) ny = ty - obj.r - 0.001;
        else ny = (ty+1) + obj.r + 0.001;
        obj.vy = 0;
      }
    }

    obj.x = nx;
    obj.y = ny;
  }

  // ---------------------------
  // Combat
  // ---------------------------
  function doAttack(){
    if (player.atkCD > 0) return;
    player.atkCD = 0.34;

    const dmg = Math.floor(18 * getAtkMult());
    const dirMag = Math.hypot(player.dirx, player.diry) || 1;
    const dx = player.dirx/dirMag;
    const dy = player.diry/dirMag;

    run.slashes.push(makeSlash(player.x, player.y, dx, dy, dmg));
    SFX.beep(520, 0.04, 0.04, "triangle");

    // hit check vs enemies in arc (cheap)
    for (const e of entities){
      if (!e.alive) continue;
      const ex = e.x - player.x;
      const ey = e.y - player.y;
      const d = Math.hypot(ex, ey);
      if (d > 1.2 + e.r) continue;
      // dot product to ensure in front-ish
      const dot = (ex/d)*(dx) + (ey/d)*(dy);
      if (dot < 0.35) continue;

      // apply damage
      e.hp -= dmg;
      e.flash = 0.08;
      VIBE.tap(16);
      SFX.hit();

      // knockback
      e.vx += dx*2.5;
      e.vy += dy*2.5;

      if (e.hp <= 0){
        e.alive = false;
        // drop aether
        const drop = 8 + Math.floor(Math.random()*10) + (e.kind==="warden" ? 30 : 0);
        pickups.push(makePickup(e.x, e.y, "aether", drop, "DROP:"+Math.random()));
        // also a relic chance if warden
        if (e.kind==="warden"){
          pickups.push(makePickup(e.x+0.5, e.y, "relic", 1, "WARDENRELIC:"+Math.random()));
          pushMsg("Warden defeated. The corridor exhales.");
        }
      }
    }
  }

  function doDash(){
    if (player.dashCD > 0 || player.dashTime > 0) return;
    player.dashTime = 0.16;
    player.invuln = Math.max(player.invuln, 0.22);
    player.dashCD = getDashCooldownBase();
    VIBE.tap(22);
    SFX.dash();
  }

  function damagePlayer(amount){
    if (player.invuln > 0) return;
    player.hp -= amount;
    player.invuln = 0.45;
    VIBE.tap(45);
    SFX.hurt();
    pushMsg("Ouch. The corridor laughs (quietly).", 1.6);
    if (player.hp <= 0){
      endRun(false);
    }
  }

  function endRun(victory){
    run.active = false;

    // Bank Aether into meta pool
    save.metaAether += player.aether;
    saveNow();

    // Show menu + summary message
    const msg = victory
      ? `Run complete. You escaped with ${player.aether} Aether.`
      : `Run ended. You banked ${player.aether} Aether.`;

    pushMsg(msg, 2.0);
    showMenu();
  }

  // ---------------------------
  // UI / Menus
  // ---------------------------
  const menu = document.getElementById("menu");
  const hud = document.getElementById("hud");
  const controls = document.getElementById("controls");

  const panelMain = document.getElementById("panelMain");
  const panelUpgrades = document.getElementById("panelUpgrades");
  const panelHow = document.getElementById("panelHow");
  const panelSettings = document.getElementById("panelSettings");
  const panelPause = document.getElementById("panelPause");

  const metaAetherEl = document.getElementById("metaAether");
  const metaAether2El = document.getElementById("metaAether2");
  const resumeBtn = document.getElementById("resumeBtn");

  function showPanel(which){
    [panelMain, panelUpgrades, panelHow, panelSettings, panelPause].forEach(p => p.style.display="none");
    which.style.display = "block";
  }

  function showMenu(){
    menu.style.display = "flex";
    hud.style.display = "none";
    controls.style.display = "none";
    showPanel(panelMain);
    resumeBtn.style.display = run.active ? "inline-block" : "none";
    updateMenuNumbers();
  }

  function hideMenu(){
    menu.style.display = "none";
    hud.style.display = "block";
    controls.style.display = "block";
  }

  function updateMenuNumbers(){
    metaAetherEl.textContent = fmt(save.metaAether);
    metaAether2El.textContent = fmt(save.metaAether);
  }

  function rebuildUpgradeList(){
    const list = document.getElementById("upgradeList");
    list.innerHTML = "";
    UPGRADES.forEach(u => {
      const lvl = clamp(save.upgrades[u.key] ?? 0, 0, u.max);
      const cost = (lvl >= u.max) ? null : upgradeCost(u, lvl);
      const row = document.createElement("div");
      row.className = "row2";
      row.innerHTML = `
        <div class="note">
          <div><b>${u.name}</b> <span class="muted">Lv ${lvl}/${u.max}</span></div>
          <div class="muted">${u.desc}</div>
        </div>
        <button class="smallbtn">${lvl>=u.max ? "Maxed" : ("Buy ("+cost+")")}</button>
      `;
      const btn = row.querySelector("button");
      btn.disabled = (lvl>=u.max) || (save.metaAether < cost);
      btn.style.opacity = btn.disabled ? 0.6 : 1.0;
      btn.addEventListener("click", ()=>{
        SFX.menu();
        if (lvl>=u.max) return;
        if (save.metaAether < cost) return;
        save.metaAether -= cost;
        save.upgrades[u.key] = lvl + 1;
        saveNow();
        rebuildUpgradeList();
      });
      list.appendChild(row);
    });
  }

  // Buttons
  document.getElementById("playBtn").addEventListener("click", ()=>{
    SFX.menu();
    resetRun();
    hideMenu();
  });
  document.getElementById("resumeBtn").addEventListener("click", ()=>{
    SFX.menu();
    hideMenu();
  });

  document.getElementById("upgradesBtn").addEventListener("click", ()=>{
    SFX.menu();
    rebuildUpgradeList();
    updateMenuNumbers();
    showPanel(panelUpgrades);
  });
  document.getElementById("backFromUpgrades").addEventListener("click", ()=>{
    SFX.menu();
    showPanel(panelMain);
  });

  document.getElementById("howBtn").addEventListener("click", ()=>{
    SFX.menu();
    showPanel(panelHow);
  });
  document.getElementById("backFromHow").addEventListener("click", ()=>{
    SFX.menu();
    showPanel(panelMain);
  });

  document.getElementById("settingsBtn").addEventListener("click", ()=>{
    SFX.menu();
    syncSettings();
    showPanel(panelSettings);
  });
  document.getElementById("backFromSettings").addEventListener("click", ()=>{
    SFX.menu();
    showPanel(panelMain);
  });

  document.getElementById("toggleSound").addEventListener("click", ()=>{
    save.settings.sound = !save.settings.sound;
    saveNow();
    SFX.menu();
  });
  document.getElementById("toggleVibe").addEventListener("click", ()=>{
    save.settings.vibe = !save.settings.vibe;
    saveNow();
    VIBE.tap(20);
    SFX.menu();
  });

  document.getElementById("resetSaves").addEventListener("click", ()=>{
    SFX.menu();
    const ok = confirm("Reset ALL saves and upgrades? This cannot be undone.");
    if (!ok) return;
    localStorage.removeItem(SAVE_KEY);
    save = loadSave();
    saveNow();
    syncSettings();
    rebuildUpgradeList();
    alert("Reset complete.");
  });

  document.getElementById("continueBtn").addEventListener("click", ()=>{
    SFX.menu();
    hidePause();
  });
  document.getElementById("quitBtn").addEventListener("click", ()=>{
    SFX.menu();
    // bank current run aether, end run
    endRun(false);
  });

  function showPause(){
    menu.style.display="flex";
    showPanel(panelPause);
  }
  function hidePause(){
    menu.style.display="none";
  }

  // ---------------------------
  // Rendering
  // ---------------------------
  function drawWorld(cam){
    // Determine tile bounds visible
    const tilesAcross = Math.ceil(cam.w / TILE) + 2;
    const tilesDown = Math.ceil(cam.h / TILE) + 2;

    const startX = Math.floor(cam.x - tilesAcross/2);
    const startY = Math.floor(cam.y - tilesDown/2);

    for (let y = 0; y < tilesDown; y++){
      for (let x = 0; x < tilesAcross; x++){
        const tx = startX + x;
        const ty = startY + y;
        const t = tileAt(tx+0.5, ty+0.5);

        const px = (tx - cam.x) * TILE + cam.w/2;
        const py = (ty - cam.y) * TILE + cam.h/2;

        // floor/wall
        if (t === SOLID){
          ctx.fillStyle = ((tx+ty)&1) ? COLORS.wall : COLORS.wall2;
          ctx.fillRect(px, py, TILE, TILE);
        }else{
          ctx.fillStyle = ((tx+ty)&1) ? COLORS.floor : COLORS.floor2;
          ctx.fillRect(px, py, TILE, TILE);

          const d = decorAt(tx, ty);
          if (d === 1){
            ctx.fillStyle = "rgba(255,255,255,0.06)";
            ctx.fillRect(px + 8, py + 10, 2, 2);
            ctx.fillRect(px + 16, py + 14, 2, 2);
          }else if (d === 2){
            ctx.strokeStyle = "rgba(255,255,255,0.05)";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(px+6, py+18);
            ctx.lineTo(px+18, py+6);
            ctx.stroke();
          }
        }
      }
    }

    // Soft glow around player area
    const gx = cam.w/2;
    const gy = cam.h/2;
    const grad = ctx.createRadialGradient(gx, gy, 40, gx, gy, 240);
    grad.addColorStop(0, COLORS.glow);
    grad.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,cam.w,cam.h);
  }

  function drawMinimap(){
    const size = 86;
    const pad = 10;
    const x0 = W - size - pad;
    const y0 = (hud.style.display==="none") ? pad : 86; // below top pills

    ctx.save();
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "rgba(20,24,34,0.72)";
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    ctx.lineWidth = 1;
    roundRect(ctx, x0, y0, size, size, 12);
    ctx.fill();
    ctx.stroke();

    const tx = Math.floor(player.x);
    const ty = Math.floor(player.y);
    const pcx = Math.floor(tx / CHUNK);
    const pcy = Math.floor(ty / CHUNK);

    const grid = 9;
    const cell = (size - 18) / grid;
    const ox = x0 + 9;
    const oy = y0 + 9;

    for (let gy2=0; gy2<grid; gy2++){
      for (let gx2=0; gx2<grid; gx2++){
        const cx = pcx + (gx2 - (grid>>1));
        const cy = pcy + (gy2 - (grid>>1));
        const key = chunkKey(cx, cy);
        const known = run.discovered.has(key);
        ctx.fillStyle = known ? "rgba(255,255,255,0.10)" : "rgba(255,255,255,0.04)";
        ctx.fillRect(ox + gx2*cell, oy + gy2*cell, cell-1, cell-1);
      }
    }

    // player dot
    ctx.fillStyle = "rgba(255,255,255,0.9)";
    ctx.beginPath();
    ctx.arc(ox + (grid>>1)*cell + cell*0.5, oy + (grid>>1)*cell + cell*0.5, 2.6, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function roundRect(ctx, x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  function drawPlayer(cam){
    const px = (player.x - cam.x) * TILE + cam.w/2;
    const py = (player.y - cam.y) * TILE + cam.h/2;

    ctx.save();
    ctx.translate(px, py);

    // invuln shimmer
    if (player.invuln > 0){
      ctx.globalAlpha = 0.45;
      ctx.fillStyle = "rgba(170,210,255,0.45)";
      ctx.beginPath();
      ctx.arc(0,0, player.r*TILE + 7, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }

    ctx.fillStyle = COLORS.player;
    ctx.beginPath();
    ctx.arc(0,0, player.r*TILE, 0, Math.PI*2);
    ctx.fill();

    // direction notch
    ctx.fillStyle = "rgba(0,0,0,0.28)";
    ctx.beginPath();
    ctx.arc(player.dirx*6, player.diry*6, 3, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
  }

  function drawSlashes(cam){
    for (const s of run.slashes){
      const sx = (s.sx - cam.x)*TILE + cam.w/2;
      const sy = (s.sy - cam.y)*TILE + cam.h/2;
      const ex = (s.ex - cam.x)*TILE + cam.w/2;
      const ey = (s.ey - cam.y)*TILE + cam.h/2;

      ctx.strokeStyle = "rgba(255,255,255,0.75)";
      ctx.lineWidth = 6;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(sx,sy);
      ctx.lineTo(ex,ey);
      ctx.stroke();

      ctx.strokeStyle = "rgba(170,210,255,0.55)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(sx,sy);
      ctx.lineTo(ex,ey);
      ctx.stroke();
    }
  }

  function drawMessage(){
    if (run.msg.t <= 0) return;
    ctx.save();
    ctx.globalAlpha = clamp(run.msg.t, 0, 1);
    const text = run.msg.text;
    ctx.font = "700 14px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    const pad = 10;
    const tw = ctx.measureText(text).width;
    const w = Math.min(W - 20, tw + pad*2);
    const x = (W - w)/2;
    const y = H - 140;
    ctx.fillStyle = "rgba(20,24,34,0.80)";
    ctx.strokeStyle = "rgba(255,255,255,0.10)";
    roundRect(ctx, x, y, w, 44, 14);
    ctx.fill(); ctx.stroke();
    ctx.fillStyle = COLORS.text;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text, W/2, y + 22);
    ctx.restore();
  }

  // ---------------------------
  // Update Loop
  // ---------------------------
  let lastT = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now - lastT) / 1000);
    lastT = now;

    pollKeyboard();

    // Menu pause logic
    if (run.active && input.pause){
      input.pause = false;
      showPause();
      return requestAnimationFrame(tickPaused);
    }

    if (run.active){
      update(dt);
      render();
      // clear one-shot inputs
      input.attack = false;
      input.dash = false;
    }else{
      // idle render background (nice)
      renderMenuBackdrop();
      // clear one-shot inputs
      input.attack = false;
      input.dash = false;
      input.pause = false;
    }

    requestAnimationFrame(tick);
  }

  function tickPaused(now){
    // while paused, still allow resume
    if (input.pause){
      input.pause = false;
      hidePause();
      lastT = performance.now();
      return requestAnimationFrame(tick);
    }
    // also let button resume/quit handle it.
    requestAnimationFrame(tickPaused);
  }

  function update(dt){
    // Discover chunks + spawn
    ensureChunkSpawnsAround(player.x, player.y);

    const tx = Math.floor(player.x);
    const ty = Math.floor(player.y);
    const pcx = Math.floor(tx / CHUNK);
    const pcy = Math.floor(ty / CHUNK);
    const key = chunkKey(pcx, pcy);
    run.discovered.add(key);

    // Depth heuristic: Manhattan distance in chunks + intra-chunk
    run.depth = Math.max(run.depth, Math.abs(pcx) + Math.abs(pcy));
    run.bestDepth = Math.max(run.bestDepth, run.depth);

    maybeSpawnWarden();

    // Exit condition: after 3 relics, spawn exit
    if (player.relics >= 3 && !player.exitSpawned){
      spawnExitNearPlayer();
    }

    // Timers
    player.invuln = Math.max(0, player.invuln - dt);
    player.atkCD = Math.max(0, player.atkCD - dt);
    player.dashCD = Math.max(0, player.dashCD - dt);

    // Movement vector
    let mx = input.moveX;
    let my = input.moveY;
    const m = Math.hypot(mx,my);
    if (m > 1){ mx/=m; my/=m; }

    if (m > 0.08){
      player.dirx = mx;
      player.diry = my;
    }

    // Dash
    if (input.dash) doDash();

    const baseSpeed = 3.0;
    let speed = baseSpeed;

    if (player.dashTime > 0){
      player.dashTime = Math.max(0, player.dashTime - dt);
      speed = 10.0;
      player.vx = player.dirx * speed;
      player.vy = player.diry * speed;
    }else{
      // smooth acceleration
      const targetVx = mx * speed;
      const targetVy = my * speed;
      const accel = 18.0;
      player.vx = lerp(player.vx, targetVx, clamp(accel*dt, 0, 1));
      player.vy = lerp(player.vy, targetVy, clamp(accel*dt, 0, 1));
    }

    // Apply movement with collision
    moveWithCollide(player, player.vx*dt, 0);
    moveWithCollide(player, 0, player.vy*dt);

    // Attack
    if (input.attack) doAttack();

    // Update slashes
    for (let i=run.slashes.length-1;i>=0;i--){
      run.slashes[i].t -= dt;
      if (run.slashes[i].t <= 0) run.slashes.splice(i,1);
    }

    // Enemies update
    for (let i=entities.length-1;i>=0;i--){
      const e = entities[i];
      if (!e.alive){ entities.splice(i,1); continue; }

      e.flash = Math.max(0, e.flash - dt);
      e.hitCD = Math.max(0, e.hitCD - dt);

      // chase
      const dx = player.x - e.x;
      const dy = player.y - e.y;
      const d = Math.hypot(dx,dy) || 1;
      const nx = dx/d, ny = dy/d;

      // simple steering with a little wobble
      const wob = Math.sin((now*0.001 + i)*2.0) * 0.18;
      const tx2 = nx + wob * (-ny);
      const ty2 = ny + wob * (nx);

      const targetVx = tx2 * e.speed;
      const targetVy = ty2 * e.speed;

      e.vx = lerp(e.vx, targetVx, clamp(8*dt, 0, 1));
      e.vy = lerp(e.vy, targetVy, clamp(8*dt, 0, 1));

      // move
      moveWithCollide(e, e.vx*dt, 0);
      moveWithCollide(e, 0, e.vy*dt);

      // touch damage
      const rr = e.r + player.r;
      if (dist2(e.x,e.y, player.x,player.y) < rr*rr){
        if (e.hitCD <= 0){
          e.hitCD = 0.55;
          damagePlayer(e.dmg);
        }
      }
    }

    // Pickups update + collect
    for (let i=pickups.length-1;i>=0;i--){
      const p = pickups[i];
      const rr = p.r + player.r;
      if (dist2(p.x,p.y, player.x,player.y) < rr*rr){
        // collect
        if (p.kind === "aether"){
          player.aether += p.amt;
          SFX.pickup(); VIBE.tap(10);
        }else if (p.kind === "heart"){
          player.hp = Math.min(player.maxHp, player.hp + p.amt);
          SFX.pickup(); VIBE.tap(10);
        }else if (p.kind === "relic"){
          player.relics += 1;
          SFX.relic(); VIBE.tap(20);
          pushMsg(`Relic acquired (${player.relics}/3).`);
        }else if (p.kind === "exit"){
          // victory
          // victory bonus based on depth
          const bonus = 20 + run.bestDepth*8 + player.relics*15;
          player.aether += bonus;
          endRun(true);
          return; // run ends now
        }

        // mark deterministic pickups as picked
        if (typeof p.id === "string" && p.id.startsWith("p:")) picked.add(p.id);

        pickups.splice(i,1);
      }
    }

    // Message timer
    run.msg.t = Math.max(0, run.msg.t - dt);

    // Cull far stuff
    cullFarEntities(player.x, player.y);

    // Death check already handled in damagePlayer.
  }

  function render(){
    ctx.clearRect(0,0,W,H);

    const cam = { x: player.x, y: player.y, w: W, h: H };

    // World
    drawWorld(cam);

    // Entities + pickups
    for (const p of pickups) p.draw(ctx, cam);
    for (const e of entities) e.draw(ctx, cam);

    // Player + slashes
    drawSlashes(cam);
    drawPlayer(cam);

    // Minimap + message
    drawMinimap();
    drawMessage();

    // HUD DOM
    const hpPct = clamp(player.hp / player.maxHp, 0, 1);
    document.getElementById("hpFill").style.width = (hpPct*100).toFixed(1)+"%";
    document.getElementById("hpText").textContent = `${Math.max(0,Math.floor(player.hp))}/${player.maxHp}`;
    document.getElementById("runText").textContent = `Depth ${run.bestDepth} • ${player.aether} Aether`;
    document.getElementById("relicText").textContent = `${player.relics}/3`;
  }

  function renderMenuBackdrop(){
    // subtle animated background behind menu
    ctx.clearRect(0,0,W,H);
    const t = performance.now()*0.001;
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0,0,W,H);

    // floaty gradients
    const g1 = ctx.createRadialGradient(W*0.35, H*0.35, 40, W*0.35, H*0.35, 300);
    g1.addColorStop(0, "rgba(120,160,255,0.10)");
    g1.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g1;
    ctx.fillRect(0,0,W,H);

    const x = W*(0.60 + Math.sin(t*0.35)*0.08);
    const y = H*(0.65 + Math.cos(t*0.28)*0.08);
    const g2 = ctx.createRadialGradient(x, y, 30, x, y, 280);
    g2.addColorStop(0, "rgba(255,140,200,0.08)");
    g2.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = g2;
    ctx.fillRect(0,0,W,H);
  }

  // ---------------------------
  // Boot
  // ---------------------------
  function start(){
    syncSettings();
    updateMenuNumbers();
    showMenu();
    requestAnimationFrame(tick);
  }

  // Pause behavior: Esc toggles pause while in run
  document.addEventListener("visibilitychange", ()=>{
    if (document.hidden && run.active){
      showPause();
    }
  });

  // PWA service worker
  if ("serviceWorker" in navigator){
    window.addEventListener("load", ()=>{
      navigator.serviceWorker.register("./sw.js").catch(()=>{});
    });
  }

  // Kickstart
  start();

  // ---------------------------
  // Tiny "readme" notes (practical):
  //
  // 1) To run locally: you need a local server (PWA + service worker won't work from file://)
  //    - Python:  python3 -m http.server 8000
  //    - Then open: http://localhost:8000
  //
  // 2) Install on iPhone:
  //    - Open in Safari, tap Share, "Add to Home Screen"
  //
  // 3) If you want store apps later:
  //    - Wrap this folder with Capacitor (iOS/Android) and ship.
  // ---------------------------
})();
</script>
</body>
</html>
